function [sys, x0,str,ts]=Sfunction(t,x,u,flag)

% Este conjunto de lineas de codigo NO se modifica.

switch flag
   case 0
   [sys, x0,str,ts]=mdlInitializeSizes;
   case 1
   sys=mdlDerivatives(t,x,u);
   case 3
   sys=mdlOutputs(t,x,u);
   case {2,4,9}
   sys=[];
   otherwise
     error(['Unhandled flag = ',num2str(flag)]);
end

end



function [sys,x0,str,ts]=mdlInitializeSizes

% Aqui se declara el numero de ecuaciones diferenciales a integrar, de va-
% riables de entrada que ingresan al macro y de salidas que este tendra.

sizes=simsizes;
sizes.NumContStates  = 6; % Numero de ecuaciones diferenciales a integrar
sizes.NumDiscStates  = 0;  
sizes.NumOutputs     = 2; % Numero de variables de salida que tendra el 
%                           macro. T chaqueta, 
sizes.NumInputs      = 3; % Numero de variables de entrada que el macro 
%                           aceptara. T entrada, T chaqueta, Flujo alim
sizes.DirFeedthrough = 0;
sizes.NumSampleTimes = 1;


sys=simsizes(sizes); % Expresion que permite que el macro funcione bien. No 
% se debe borrar.

% Este es el SS o condiciones iniciales que pueden editar después de la parte a).
x0 = [0, 0, 0];


% Estas 2 lineas de codigo NO se tocan.
str=[]; 
ts=[0 0];
end

function sys=mdlDerivatives(~,x,u)

% Variables de Estado    
X  = x(1); %[g/L] biomasa
S  = x(2); %[g/L] sustrato (glucosa)
P  = x(3); %[g/L] subproducto (etanol)
V  = x(4); %[L] volumen de cultivo
Tm = x(5); %[K] temperatura del mosto
Tc = x(6); %[K] temperatura de la chaqueta

% Entradas
Falim = u(1); %[L/s]? flujo de alimentacion de glucosa
Fc    = u(2); %[L/s]? flujo de refrigerante en la chaqueta

% Parámetros
D = Falim/V; %[s] tasa de dilución
O = 0; %[g/L] concentración de saturación de oxígeno

kx1 = 0; %coeficiente de rendimiento de biomasa 1
kx2 = 0; %coeficiente de rendimiento de biomasa 2
kx3 = 0; %coeficiente de rendimiento de biomasa 3
ks1 = 0; %coeficiente de rendimiento de sustrato 1
ks2 = 0; %coeficiente de rendimiento de sustrato 2
kp2 = 0; %coeficiente de rendimiento de subproducto 2
kp3 = 0; %coeficiente de rendimiento de subproducto 3

mu_s   = 0;
mu_o   = 0;
Ks     = 0;
Kip    = 0;
Ko     = 0;
Kp     = 0;
kos    = 0;
kop    = 0;
rs     = mu_s*S/(S+Ks);
rscrit = mu_o*O*Kip/(kos*(O+Ko)*(Kip+P));
r1     = min(rs, rscrit)/ks1; 
r2     = max(0, rs-rscrit)/ks2; 
r3     = max(0, kos*(rscrit-rs)*P/(kop*(P+Kp)))/kp3;


% Ecuaciones de Estado (balances de masa)
dXdt = (kx1*r1 + kx2*r2 + kx3*r3)*X - D*X;
dSdt = -(ks1*r1+ks2*r2)*X + D*Sin - D*S;
dPdt = (kp2*r2-kp3*r3)*X - D*P;
dVdt = Falim;
dTmdt = 0;
dTcdt = 0;

sys = [dXdt, dSdt, dPdt, dVdt, dTmdt, dTcdt];
end

function sys=mdlOutputs(~,x,~)

% Aqui se presenta el vector de salidas que tendra este macro, las cuales
% se ordenan para facilitar la colocacion de los bloques:

sys = x;

end